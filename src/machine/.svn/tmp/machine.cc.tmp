// Author: Alex Thomson

#include "machine/machine.h"

#include <glog/logging.h>
#include <atomic>

#include "machine/cluster_config.h"
#include "machine/connection/connection.h"
#include "machine/connection/connection_zmq.h"
#include "machine/app/app.h"
#include "machine/app/app_starter.h"
#include "machine/thread_pool/thread_pool.h"
#include "common/types.h"
#include "common/utils.h"
#include "proto/header.pb.h"

using std::atomic;

class ConnectionLoopMessageHandler : public MessageHandler {
 public:
  explicit ConnectionLoopMessageHandler(Machine* machine, ThreadPool* tp)
    : machine_(machine), tp_(tp) {
  }
  virtual ~ConnectionLoopMessageHandler() {}

  virtual void HandleMessage(Header* header, MessageBuffer* message) {
    CHECK(header->has_type());
    // TODO(agt): Better header validity checking.

    switch (header->type()) {
      // Hand RPC requests and CALLBACK invocations off to ThreadPool.
      //
      // TODO(agt): Support inline RPCs?
      case Header::RPC:
      case Header::CALLBACK:
        tp_->HandleMessage(header, message);
        break;

      // Ack: increment ack counter
      case Header::ACK:
        ++(*reinterpret_cast<atomic<int>*>(header->ack_counter()));
        break;

      // Data packets can be delivered directly.
      case Header::DATA:
        if (header->has_data_ptr()) {
          *reinterpret_cast<MessageBuffer**>(header->data_ptr()) = message;
        } else {
          machine_->GetApp(header->data_app())->DeliverData(
              header->data_channel(),
              message);
        }
        delete header;
        break;

      case Header::SYSTEM:
        // TODO(kun): handle special system messages (e.g. 'stop', 'add_app',
        //            etc.) here.

        if (header->rpc() == "addapp") {
          LOG(ERROR) << " Machine " << (int)machine_->machine_id()
                     <<" : Receive AddApp message.";
          // For add_app, run Machine::AddApp?
          // machine_->AddApp(sap);
          // (TODO)(kun & Alex) : implement this.

        } else if (header->rpc() == "stop") {
          LOG(ERROR) << " Machine " << (int)machine_->machine_id()
                     << " : Receive TearDownCluster message.";
          // Stop gracefully
          machine_->Set_stopped();
        }
        delete header;
        break;

      default:
        LOG(FATAL) << "unknown Header::type(): " << header->type();
    }
  }

 private:
  Machine* machine_;
  ThreadPool* tp_;
};

class WorkerThreadMessageHandler : public MessageHandler {
 public:
  explicit WorkerThreadMessageHandler(Machine* machine) : machine_(machine) {}
  virtual ~WorkerThreadMessageHandler() {}
  virtual void HandleMessage(Header* header, MessageBuffer* message) {
    // Handle RPC request
    CHECK(header->has_app());
    machine_->GetApp(header->app())->HandleMessage(header, message);
  }

 private:
  Machine* machine_;
};

Machine::Machine(uint64 machine_id, const ClusterConfig& config)
    : machine_id_(machine_id), config_(config), stop_(false) {
  InitializeComponents();
  apps_["AppStarter"] = new AppStarter();
  apps_["AppStarter"]->name_ = "AppStarter";
  apps_["AppStarter"]->machine_ = this;
}

Machine::Machine(
    uint64 machine_id,
    const ClusterConfig& config,
    ThreadPool* tp,
    Connection* connection)
      : machine_id_(machine_id), config_(config), thread_pool_(tp),
        connection_(connection), stop_(false) {
  apps_["AppStarter"] = new AppStarter();
  apps_["AppStarter"]->name_ = "AppStarter";
  apps_["AppStarter"]->machine_ = this;
}

Machine::~Machine() {
  for (map<string, App*>::iterator it = apps_.begin(); it != apps_.end();
       ++it) {
    it->second->Stop();
  }
  delete connection_;
  delete thread_pool_;
  for (map<string, App*>::iterator it = apps_.begin(); it != apps_.end();
       ++it) {
    delete it->second;
  }
}

void Machine::SendMessage(Header* header, MessageBuffer* message) {
  // TODO(agt): Check header validity.
  message->Append(*header);
  connection_->SendMessage(header->to(), message);
  delete header;
}

void Machine::SendReplyMessage(Header* header, MessageBuffer* message) {
  header->set_to(header->from());
  header->set_from(machine_id());
  if (header->has_data_ptr() ||
      (header->has_data_app() && header->has_data_channel())) {
    header->set_type(Header::DATA);
    SendMessage(header, message);
  } else if (header->has_callback_app() && header->has_callback_rpc()) {
    header->set_type(Header::CALLBACK);
    header->set_app(header->callback_app());
    header->set_rpc(header->callback_rpc());
    header->clear_callback_app();
    header->clear_callback_rpc();
    SendMessage(header, message);
  } else if (header->has_ack_counter()) {
    // Send an empty message instead of the provided message.
    header->set_type(Header::ACK);
    SendMessage(header, new MessageBuffer());
    delete message;
  } else {
    // No reply requested.
    delete header;
    delete message;
  }
}

void Machine::AddApp(const StartAppProto& sap) {
  reinterpret_cast<AppStarter*>(GetApp("AppStarter"))->StartApp(sap);
}

App* Machine::GetApp(const string& name) {
  if (apps_.count(name) == 0) {
    LOG(FATAL) << "GetApp(): nonexistant app: " << name;
    return NULL;
  }
  return apps_[name];
}

void Machine::InitializeComponents() {
  thread_pool_ = new ThreadPool(new WorkerThreadMessageHandler(this));
  connection_ = new ConnectionZMQ(
      machine_id_,
      config_,
      new ConnectionLoopMessageHandler(this, thread_pool_));
  Spin(0.2);
}

